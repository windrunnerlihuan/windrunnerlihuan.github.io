<!DOCTYPE html>
<html >
<head>
  
    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="zzKGwrFJYw" />
  
  <title>插件开发中的资源问题分析及填坑处理 | April is your lie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;做插件开发有两个问题需要解决，一个是资源文件加载，另一个是关于四大组件生命周期的管理。这里我们就简单分析会遇到那些坑，和一些简单的处理方法或者思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="插件开发中的资源问题分析及填坑处理">
<meta property="og:url" content="http://windrunnerlihuan.com/2016/09/05/插件开发中的资源问题分析及填坑处理/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;做插件开发有两个问题需要解决，一个是资源文件加载，另一个是关于四大组件生命周期的管理。这里我们就简单分析会遇到那些坑，和一些简单的处理方法或者思路。">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/adb.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/apk.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/meizi.jpg">
<meta property="og:updated_time" content="2016-09-05T22:28:17.652Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="插件开发中的资源问题分析及填坑处理">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;做插件开发有两个问题需要解决，一个是资源文件加载，另一个是关于四大组件生命周期的管理。这里我们就简单分析会遇到那些坑，和一些简单的处理方法或者思路。">
<meta name="twitter:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/adb.png">
  
    <link rel="alternative" href="/atom.xml" title="April is your lie" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
          search: true
      }
  </script>

  
      <script>
          yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
      </script>
  

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
  <!-- 自动推送工具代码 start -->
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- 自动推送工具代码 end -->
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">windrunnerlihuan</a></h1>
        </hgroup>

        
        <p class="header-subtitle">四月是你的谎言</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" results="0" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="undefined" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">时间轴</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC/">IPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SO库/">SO库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SurfaceFlinger/">SurfaceFlinger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客搭建/">博客搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/壁纸/">壁纸</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多媒体/">多媒体</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/属性动画/">属性动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/弹幕/">弹幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件开发/">插件开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息/">消息</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动直播/">移动直播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://gank.io/">干货集中营</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jcodecraeer.com/">泡在网上的日子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://trinea.cn/">Trinea</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">windrunnerlihuan，开发小菜一枚，坐标位于上海。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
            </hgroup>
            
            <p class="header-subtitle">四月是你的谎言</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">时间轴</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-插件开发中的资源问题分析及填坑处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/05/插件开发中的资源问题分析及填坑处理/" class="article-date">
      <time datetime="2016-09-05T10:44:12.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      插件开发中的资源问题分析及填坑处理
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android技术点/">Android技术点</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SO库/">SO库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/插件开发/">插件开发</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&#160; &#160; &#160; &#160;做插件开发有两个问题需要解决，一个是资源文件加载，另一个是关于四大组件生命周期的管理。这里我们就简单分析会遇到那些坑，和一些简单的处理方法或者思路。<br><a id="more"></a><br>&#160; &#160; &#160; &#160;插件开发目前已经不是什么最新技术了，目前市面上已有很多成熟的方案和开源工程，比如<code>任玉刚</code>的<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a>、阿里的<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>和<a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">dexposed</a>、360的<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>、QQ空间的<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">nuwa</a>。各家实现方案也是各有不同，这些开源库大多已经广泛应用于很多市面上的软件。<br>&#160; &#160; &#160; &#160;说到未来，不得不提一下<strong>ReactNative</strong>，移动应用web化一定是一个必然的趋势，就好像曾经的桌面应用由C/S到B/S的转变。而怎么web化才是关键之处。但目前<strong>RN</strong>在IOS开发中优势很明显，在Android中却是挖坑不断。</p>
<h1 id="普通插件开发"><a href="#普通插件开发" class="headerlink" title="普通插件开发"></a>普通插件开发</h1><h2 id="开发前提"><a href="#开发前提" class="headerlink" title="开发前提"></a>开发前提</h2><p>&#160; &#160; &#160; &#160;Android为我们从ClassLoader派生出了两个类：<strong>DexClassLoader</strong>和<strong>PathClassLoader</strong>。在加载类的时候，是执行父类ClassLoader的loadClass方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Don't want to see this.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因此DexClassLoader和PathClassLoader都属于符合双亲委派模型的类加载器（因为它们没有重载loadClass方法）。也就是说，它们在加载一个类之前，回去检查自己以及自己以上的类加载器是否已经加载了这个类。如果已经加载过了，就会直接将之返回，而不会重复加载。<br>&#160; &#160; &#160; &#160;这两者的区别在于DexClassLoader需要提供一个可写的outpath路径，用来释放.apk包或者.jar包中的dex文件。换个说法来说，就是PathClassLoader不能主动从zip包中释放出dex，因此只支持直接操作dex格式文件，或者已经安装的apk（因为已经安装的apk在cache中存在缓存的dex文件）。而DexClassLoader可以支持.apk、.jar和.dex文件，并且会在指定的outpath路径释放出dex文件。<br>&#160; &#160; &#160; &#160;因此，我们要实现插件开发，需要用DexClassLoader。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>&#160; &#160; &#160; &#160;如果只需要加载插件apk中一个普通的类，只要构造一个DexClassLoader，它的构造方法对每个参数已经说明的很清楚了，我们可以试验一下。<br>&#160; &#160; &#160; &#160;新建一个插件工程TestPlugin，里面放一个类Plugin.java，再放一个简单的方法，即TestPlugin/src/com/example/plugin/Plugin.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCommonStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"COMMON"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后新建一个宿主工程TestHost，在MainActivity里面写一个加载插件的方法，即TestHost/src/com/example/host/MainActivity.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		loadPluginClass();		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//定义DexClassLoader  </span></span><br><span class="line">    <span class="comment">//第一个参数：是dex压缩文件的路径  </span></span><br><span class="line">    <span class="comment">//第二个参数：是dex解压缩后存放的目录  </span></span><br><span class="line">    <span class="comment">//第三个参数：是C/C++依赖的本地库文件目录,可以为null  </span></span><br><span class="line">    <span class="comment">//第四个参数：是上一级的类加载器  </span></span><br><span class="line">	DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(<span class="keyword">this</span>.getCacheDir().getAbsolutePath() + File.separator + <span class="string">"TestPlugin.apk"</span>,</span><br><span class="line">	<span class="keyword">this</span>.getCacheDir().getAbsolutePath(), <span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = dexClassLoader .loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pluginClass == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"plugin class cann't be found"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line"></span><br><span class="line">	Method pluginMethod = pluginClass.getMethod(<span class="string">"getCommonStr"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pluginMethod == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"plugin method cann't be found"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String methodStr = (String) pluginMethod .invoke(pluginObject);</span><br><span class="line">	Log.e(TAG, <span class="string">"Print Method str = "</span> + methodStr);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先安装宿主程序TestHost.apk，然后将插件TestPlugin.apk放到/data/data/com.example.host/cache/下面，再次运行宿主程序，会打印如下log：<br>&#160; &#160; &#160; &#160;Print Method str = COMMON<br>&#160; &#160; &#160; &#160;这个应该比较随意了，会使用DexClassLoader这个类的开发者都是轻车熟路。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="普通资源"><a href="#普通资源" class="headerlink" title="普通资源"></a>普通资源</h3><p>&#160; &#160; &#160; &#160;我们知道插件apk中的资源文件是无法直接加载的，因为插件apk并没有安装，所以没有给每个资源生成特定的资源id，所以我们没法使用R.XXX去引用。<br>&#160; &#160; &#160; &#160;不过我们通过android系统安装apk时对资源文件的处理流程中发现可以通过AssetManager这个类完成对插件中资源的引用。Java的源码中发现，它有一个私有方法addAssetPath，只需要将apk的路径作为参数传入，我们就可以获得对应的AssetsManager对象，然后我们就可以使用AssetsManager对象，创建一个Resources对象，然后就可以从Resource对象中访问apk中的资源了。总结如下：</p>
<ul>
<li>新建一个AssetManager对象</li>
<li>通过反射调用addAssetPath方法</li>
<li>以AssetsManager对象为参数，创建Resources对象即可</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们测试demo可以写一个工具类，省略了一部分，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginBaseImpl</span> <span class="keyword">extends</span> <span class="title">PluginBase</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Resources <span class="title">loadResource</span><span class="params">(Context parentContext, String apkPath)</span> </span>&#123;</span><br><span class="line">		Resources ret = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">			Method method = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">			method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			method.invoke(assetManager, apkPath);</span><br><span class="line">			ret = <span class="keyword">new</span> Resources(assetManager, parentContext.getResources().getDisplayMetrics(), parentContext.getResources().getConfiguration());</span><br><span class="line">			Log.e(TAG, <span class="string">"loadResources succeed"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			Log.e(TAG, <span class="string">"loadResources faided"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后我们再插件工程里面再添加一个方法，再放入一个简单的资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getContextStr</span><span class="params">(Resources resources)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> resources.getString(R.string.plugin_str);<span class="comment">//&lt;string name="plugin_str"&gt;PLUGIN&lt;/string&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;测试如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	...省略一些初始化代码...</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//构造一个DexClassLoader</span></span><br><span class="line">	DexClassLoader  dexClassLoader = mPluginBase.makeDexClassLoader(APK_PATH, DEX_PATH,</span><br><span class="line">	<span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = mDexClassLoader.loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	......</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line">	<span class="comment">//加载插件apk资源</span></span><br><span class="line">	Resources pluginResources = mPluginBase.loadResource(<span class="keyword">this</span>, APK_PATH);</span><br><span class="line">	</span><br><span class="line">	Method m2 = pluginClass.getMethod(<span class="string">"getContextStr"</span>, Resources.class);</span><br><span class="line">	String methodStr2 = (String) m2.invoke(pluginObject, pluginResources);</span><br><span class="line">	Log.e(TAG, <span class="string">"Print Resource str = "</span> + methodStr2);</span><br><span class="line">	......		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;运行之后，打印log如下：<br>&#160; &#160; &#160; &#160;Print Resource str = PLUGIN</p>
<h3 id="Layout资源"><a href="#Layout资源" class="headerlink" title="Layout资源"></a>Layout资源</h3><p>&#160; &#160; &#160; &#160;如果要使用插件apk里面的layout资源，比如引用某个布局文件TestPlugin/res/layout/plugin.xml，就需要做一做处理。<br>&#160; &#160; &#160; &#160;一般从layout转换成view需要用到LayoutInflate，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View view = LayoutInflater.from(context).inflate(R.layout.plugin, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;但是这个context不能直接传宿主程序的context，否则回报一个资源id没有找到异常。我们跟着LayoutInflate的源码进去看看，问题出在哪儿：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Inflate时会调用到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//这句返回的resource是宿主程序ContextImpl里的resource，即宿主程序的resource</span></span><br><span class="line">        <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">        </span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//所以这里在宿主resource里当然找不到插件资源id了，这个里面抛出了异常</span></span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们看到inflate时还是在宿主程序的资源里查找了插件资源，因此回报异常。不过我们可以投机取巧一下，重写一个LayoutInflate的Inflate第二个重载方法。在插件工程里可以做如下测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">		<span class="function"><span class="keyword">public</span> LinearLayout <span class="title">getLinearLayout</span><span class="params">(Context context, <span class="keyword">final</span> Resources resources)</span></span>&#123;</span><br><span class="line">		LayoutInflater inflater = <span class="keyword">new</span> LayoutInflater(context) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root,</span><br><span class="line">					<span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		        final Resources res = getContext().getResources(); //注释掉这行</span></span><br><span class="line">		        <span class="keyword">final</span> Resources res = resources; <span class="comment">//替换为插件apk资源</span></span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">		        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		            parser.close();</span><br><span class="line">		        &#125;</span><br><span class="line">			&#125;    </span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> (LinearLayout) inflater.inflate(R.layout.plugin_layout, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后在宿主程序里写上测试demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	...省略一些初始化代码...</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//构造一个DexClassLoader</span></span><br><span class="line">	DexClassLoader  dexClassLoader = mPluginBase.makeDexClassLoader(APK_PATH, DEX_PATH,</span><br><span class="line">	<span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = mDexClassLoader.loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	......</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line">	<span class="comment">//加载插件apk资源</span></span><br><span class="line">	Resources pluginResources = mPluginBase.loadResource(<span class="keyword">this</span>, APK_PATH);</span><br><span class="line">	<span class="comment">//测试插件layout文件</span></span><br><span class="line">	Method m3 = pluginClass.getMethod(<span class="string">"getLinearLayout"</span>, Context.class, Resources.class);</span><br><span class="line">	LinearLayout pluginView = (LinearLayout) m3.invoke(pluginObject, <span class="keyword">this</span>, pluginResources );</span><br><span class="line">	<span class="keyword">this</span>.addContentView(pluginView, <span class="keyword">new</span> RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">	......		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过测试，插件的layout布局被加入到了宿主界面上，图片就不贴了。</p>
<h3 id="另外三种方式"><a href="#另外三种方式" class="headerlink" title="另外三种方式"></a>另外三种方式</h3><p>&#160; &#160; &#160; &#160;上面的方法其实还是有些繁琐，如果要封装的完善一些可以尝试下面三种方案：</p>
<ul>
<li>创建一个自己的ContextImpl，Override其方法</li>
<li>通过反射，直接替换当前context的mResources私有成员变量</li>
<li>反射替换ActivityThread里的Instrumentation，将插件资源和宿主资源整合</li>
</ul>
<p>(1) 创建自己的Context：<br>&#160; &#160; &#160; &#160;要构建自己的Context，就得继承ContextWrapper类，（Context类和它的一些子类大家应该都清楚）然后重写里面的一些重要方法。实例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginContext</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"PluginContext"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DexClassLoader mClassLoader ;</span><br><span class="line">    <span class="keyword">private</span> Resources mResources;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    PluginContext(Context context, String pluginPath, String optimizedDirectory, String libraryPath) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context.getApplicationContext());</span><br><span class="line">        </span><br><span class="line">        Resources resc = context.getResources();</span><br><span class="line">        <span class="comment">//隐藏API是这样的</span></span><br><span class="line">        <span class="comment">//AssetManager assets = new AssetManager();</span></span><br><span class="line">        AssetManager assets = AssetManager.class.newInstance();</span><br><span class="line">        assets.addAssetPath(pluginPath);</span><br><span class="line"></span><br><span class="line">		mClassLoader = <span class="keyword">new</span> DexClassLoader(pluginPath, optimizedDirectory, libraryPath, context.getClassLoader());</span><br><span class="line">        mResources = <span class="keyword">new</span> Resources(assets, resc.getDisplayMetrics(), </span><br><span class="line">                resc.getConfiguration(), resc.getCompatibilityInfo(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//隐藏API是这样的</span></span><br><span class="line">        <span class="comment">//mInflater = PolicyManager.makeNewLayoutInflater(this);</span></span><br><span class="line">        mInflater = <span class="keyword">new</span> LayoutInflater(context) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root,</span><br><span class="line">					<span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		        final Resources res = getContext().getResources();</span></span><br><span class="line">		        <span class="keyword">final</span> Resources res = mResources;</span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">		        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		            parser.close();</span><br><span class="line">		        &#125;</span><br><span class="line">			&#125;    </span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources.getAssets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == Context.LAYOUT_INFLATER_SERVICE)</span><br><span class="line">            <span class="keyword">return</span> mInflater;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Theme mTheme;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mTheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> resid = Resources.selectDefaultTheme(<span class="number">0</span>,</span><br><span class="line">                        getBaseContext().getApplicationInfo().targetSdkVersion);</span><br><span class="line">                mTheme = mResources.newTheme();</span><br><span class="line">                mTheme.applyStyle(resid, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mTheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样我们插件的Context就构造完成了，以后就可以使用这个Context加载插件中的资源文件了。</p>
<p>(2) 替换当前context的mResources私有成员变量：<br>&#160; &#160; &#160; &#160;这个需要在Activity的attachBaseContext方法中替换它的Context，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">		replaceContextResources(newBase);</span><br><span class="line">		<span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * 使用反射的方式，使用mPluginResources对象，替换Context的mResources对象</span><br><span class="line">     * <span class="doctag">@param</span> context</span><br><span class="line">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceContextResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field field = context.getClass().getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">			field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			field.set(context, mPluginResources);</span><br><span class="line">			Log.e(TAG, <span class="string">"replace resources succeed"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			Log.e(TAG, <span class="string">"replace resources failed"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3) 反射替换ActivityThread里的Instrumentation，将插件资源和宿主资源整合:<br>&#160; &#160; &#160; &#160;AssetManager的addAssetPath()法调用native层AssetManager对象的addAssetPath()法，通过查看c++代码可以知道，该方法可以被调用多次，每次调用都会把对应资源添加起来，而后来添加的在使用资源是会被首先搜索到。可以怎么理解，C++层的AssetManager有一个存放资源的栈，每次调用addAssetPath()法都会把资源对象压如栈，而在读取搜索资源时是从栈顶开始搜索，找不到就往下查。所以我们可以这样来处理AssetManager并得到Resources。<br>&#160; &#160; &#160; &#160;使用到资源的地方归纳起来有两处，一处是在Java代码中通过Context.getResources获取，一处是在xml文件（如布局文件）里指定资源，其实xml文件里最终也是通过Context来获取资源的只不过是他一般获取的是Resources里的AssetManager。所以，我们可以在Context对象被创建后且还未使用时把它里面的Resources（mResources）替换掉。整个应用的Context数目等于Application+Activity+Service的数目，Context会在这几个类创建对象的时候创建并添加进去。而这些行为都是在ActivityTHread和Instrumentation里做的。<br>&#160; &#160; &#160; &#160;以Activity为例，步骤如下：<br>&#160; &#160; &#160; &#160;1. Activity对象的创建是在ActivityThread里调用Instrumentation的newActivity方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//Instrumentation类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span><br><span class="line">            Intent intent)</span></span><br><span class="line">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2.Context对象的创建是在ActivityThread里调用createBaseContextForActivity方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;3.Activity绑定Context是在ActivityThread里调用Activity对象的attach方法，其中appContext就是上面创建的Context对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.voiceInteractor);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;替换掉Activity里Context里的Resources最好要早，基于上面的观察，我们可以在调用Instrumentation的callActivityOnCreate（）方法时把Resources替换掉。那么问题又来了，我们如何控制callActivityOnCreate（）方法的执行，这里又得使用hook的思想了，即把ActivityThread里面的Instrumentation对象（mInstrumentation）给替换掉，同样得使用反射。步骤如下:<br>&#160; &#160; &#160; &#160;1. 获取ActivityThread对象:<br>&#160; &#160; &#160; &#160;ActivityThread里面有一个静态方法，该方法返回的是ActivityThread对象本身，所以我们可以调用该方法来获取ActivityTHread对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sCurrentActivityThread;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而ActivityThread是被hide的，所以得通过反射来处理，处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ActivityThread类</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line"><span class="comment">//获取currentActivityThread方法</span></span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//获取ActivityThread对象</span></span><br><span class="line">Object CurrentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2. 获取ActivityThread里的Instrumentation对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(CurrentActivityThread);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;3. 构建我们自己的Instrumentation对象，并从写callActivityOnCreate方法<br>在callActivityOnCreate方法里要先获取当前Activity对象里的Context（mBase），再获取Context对象里的Resources（mResources）变量，在把mResources变量指向我们构造的Resources对象，做到移花接木。构建我们的MyInstrumentation类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Instrumentation mInstrumentationParent;</span><br><span class="line">	<span class="keyword">private</span> Context mContextParent;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyInstrumentation</span><span class="params">(Instrumentation instrumentation, Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		mInstrumentationParent = instrumentation;</span><br><span class="line">		mContextParent = context;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field mBaseField = Activity.class.getSuperclass().getSuperclass().getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">			mBaseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			Context mBase = (Context) mBaseField.get(activity);</span><br><span class="line">			</span><br><span class="line">			Class&lt;?&gt; contextImplClazz = Class.forName(<span class="string">"android.app.ContextImpl"</span>);</span><br><span class="line">			Field mResourcesField = contextImplClazz.getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">			mResourcesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			</span><br><span class="line">			String dexPath = activity.getCacheDir() + File.separator + <span class="string">"TestPlugin.apk"</span>;</span><br><span class="line">			String dexPath2 = mContextParent.getApplicationContext().getPackageCodePath();</span><br><span class="line">			</span><br><span class="line">			AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">			Method addAssetPath = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">			addAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			</span><br><span class="line">			addAssetPath.invoke(assetManager, dexPath);</span><br><span class="line">			addAssetPath.invoke(assetManager, dexPath2);</span><br><span class="line">			</span><br><span class="line">			Method ensureStringBlocksMethod = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">			ensureStringBlocksMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			ensureStringBlocksMethod.invoke(assetManager);</span><br><span class="line">			</span><br><span class="line">			Resources superRes = mContextParent.getResources();</span><br><span class="line">			Resources resources = <span class="keyword">new</span> Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">			</span><br><span class="line">			mResourcesField.set(mBase, resources);</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.callActivityOnCreate(activity, icicle);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;4. 最后，使ActivityThread里面的mInstrumentation变量指向我们构建的MyInstrumentation对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">	 <span class="comment">//获取ActivityThread类</span></span><br><span class="line">       Class&lt;?&gt; activityThreadClass;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">		<span class="comment">//获取currentActivityThread方法</span></span><br><span class="line">		Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">		currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//获取ActivityThread对象</span></span><br><span class="line">		Object CurrentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//获取Instrumentation变量</span></span><br><span class="line">		Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">        mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(CurrentActivityThread);</span><br><span class="line">		<span class="comment">//构建自己的Instrumentation对象</span></span><br><span class="line">        Instrumentation proxy = <span class="keyword">new</span> MyInstrumentation(mInstrumentation, context);</span><br><span class="line">        <span class="comment">//移花接木</span></span><br><span class="line">        mInstrumentationField.set(CurrentActivityThread, proxy);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="加载SO库流程分析和填坑"><a href="#加载SO库流程分析和填坑" class="headerlink" title="加载SO库流程分析和填坑"></a>加载SO库流程分析和填坑</h2><p>&#160; &#160; &#160; &#160;插件加载带有动态库的apk时，会报UnsatisfiedLinkError找不到动态库的错误原因是我们没有动态指定so库的路径。<br>&#160; &#160; &#160; &#160;解决方法是在DexClassLoader中第三个参数书指定so库的目录路径，因此我们需要把动态库给解压出来放到data/data/xx（package）目录下。<br>&#160; &#160; &#160; &#160;这个，我把so文件放到了/data/data/com.example.host/cache/下面，然后给我们的DexClassLoader第三个参数指定了这个目录，然后在插件工程里调用System.loadLibrary方法就不会报错了。</p>
<p>&#160; &#160; &#160; &#160;关于解压so文件和获取手机CPU的ABI类型这里就不在赘述，网上也是大把的代码。我们主要分析一下Android找寻so和加载的流程：</p>
<h3 id="SO库加载过程"><a href="#SO库加载过程" class="headerlink" title="SO库加载过程"></a>SO库加载过程</h3><p>&#160; &#160; &#160; &#160;在Android中如果想使用so的话，首先得先加载，加载现在主要有两种方法，一种是直接System.loadLibrary方法加载工程中的libs目录下的默认so文件，这里的加载文件名是xxx，而整个so的文件名为：libxxx.so。还有一种是加载指定目录下的so文件，使用System.load方法，这里需要加载的文件名是全路径，比如：xxx/xxx/libxxx.so。<br>&#160; &#160; &#160; &#160;我们可以看看System类的这两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这两个方法都会进入到Runtime类的不同方法中，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//load方法比较简单</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(String absolutePath, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (absolutePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"absolutePath == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//都会调用doLoad方法</span></span><br><span class="line">       String error = doLoad(absolutePath, loader);</span><br><span class="line">       <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//loadLibrary比较复杂</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;<span class="comment">//这个loader就是加载目标类的ClassLoader，宿主工程为系统指定的PathClassLoader，插件工程为我们构造的DexClassLoader</span></span><br><span class="line">        <span class="comment">//首先会从一些指定目录中查找指定名字的so文件</span></span><br><span class="line">           String filename = loader.findLibrary(libraryName);</span><br><span class="line">           <span class="comment">//如果没有找到就会抛异常</span></span><br><span class="line">           <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;<span class="comment">//这个异常就是我们没有指定DexClassLoader第三个参数时报的异常</span></span><br><span class="line">               <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">               <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">               <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">               <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                              System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//都会调用doLoad方法</span></span><br><span class="line">           String error = doLoad(filename, loader);</span><br><span class="line">           <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//下面逻辑是当指定ClassLoader为null时，就在一些系统so库目录中查找</span></span><br><span class="line">       String filename = System.mapLibraryName(libraryName);</span><br><span class="line">       List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       String lastError = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">           String candidate = directory + filename;</span><br><span class="line">           candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">               String error = doLoad(candidate, loader);</span><br><span class="line">               <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">               &#125;</span><br><span class="line">               lastError = error;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们这里详细分析一下loadLibrary方法。首先会判断指定的ClassLoader是否为空，这里传入的值为VMStack.getCallingClassLoader()，就是加载目标类的ClassLoader，宿主工程为系统指定的PathClassLoader，插件工程为我们构造的DexClassLoader。</p>
<p>&#160; &#160; &#160; &#160;然后执行：String filename = loader.findLibrary(libraryName);<br>这一步其实是调用PathClassLoader和DexClassLoader共同父类BaseDexClassLoader的findLibrary方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span><br><span class="line">           String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(parent);</span><br><span class="line">       <span class="comment">//pathList在构造方法中赋值</span></span><br><span class="line">       <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseDexClassLoader的findLibrary方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;BaseDexClassLoader的findLibrary方法内部又调用了DexPathList的findLibrary方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DexPathList的findLibrary方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换指定libraryName为so库文件名，例如turn "MyLibrary" into "libMyLibrary.so".</span></span><br><span class="line">       String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">       <span class="comment">//在nativeLibraryDirectories中遍历目标so库是否存在</span></span><br><span class="line">       <span class="keyword">for</span> (File directory : nativeLibraryDirectories) &#123;</span><br><span class="line">           String path = <span class="keyword">new</span> File(directory, fileName).getPath();</span><br><span class="line">           <span class="keyword">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">               <span class="keyword">return</span> path;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span><br><span class="line">           String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//也是在构造方法中给nativeLibraryDirectories 赋值；</span></span><br><span class="line">	<span class="comment">//libraryPath就是我们在DexClassLoader中指定的第三个参数,系统的PathClassLoader指定为/data/app-lib/xxx(包名)</span></span><br><span class="line">       <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//GO ON 继续跟踪</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> File[] splitLibraryPath(String path) &#123;</span><br><span class="line">       <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">       <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">//   1. this class loader's library path for application libraries</span></span><br><span class="line">       <span class="comment">//   2. the VM's library path from the system property for system libraries</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//System.getProperty("java.library.path")返回的是/vendor/lib:/system/lib</span></span><br><span class="line">       ArrayList&lt;File&gt; result = splitPaths(path, System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> File[result.size()]);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//NEXT  path1为我们在DexClassLoader中指定的第三个参数,系统的PathClassLoader指定为/data/app-lib/xxx(包名)；path2为/vendor/lib:/system/lib；wantDirectories为true</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;File&gt; <span class="title">splitPaths</span><span class="params">(String path1, String path2,</span><br><span class="line">           <span class="keyword">boolean</span> wantDirectories)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">       ArrayList&lt;File&gt; result = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">       splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">       splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//FINALLY 用“:”分割路径字符串，并且将这些路径都放入到一个ArrayList中</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitAndAdd</span><span class="params">(String searchPath, <span class="keyword">boolean</span> directoriesOnly,</span><br><span class="line">           ArrayList&lt;File&gt; resultList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (searchPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (String path : searchPath.split(<span class="string">":"</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               StructStat sb = Libcore.os.stat(path);</span><br><span class="line">               <span class="keyword">if</span> (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                   resultList.add(<span class="keyword">new</span> File(path));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码就是查找so库文件的逻辑了，会分别在/vendor/lib、/system/lib、/data/app-lib/xxx(包名)、和指定目录下查找，如果找不到，就会报UnsatisfiedLinkError异常。</p>
<p>&#160; &#160; &#160; &#160;查找逻辑就先到这里，继续回到Runtime类中。接着就会调用doLoad方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">       String ldLibraryPath = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        <span class="comment">//ldLibraryPath就是上面提到的vendor/lib、/system/lib、/data/app-lib/xxx(包名)、和指定目录用“:”连接的字符串</span></span><br><span class="line">           ldLibraryPath = ((BaseDexClassLoader) loader).getLdLibraryPath();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//最后会调用nativeLoad方法</span></span><br><span class="line">           <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, String ldLibraryPath)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里调用了本地方法，不过悲催的是，我的ART版本代码没有找到，所以只能看 Dalvik版本的。 Runtime类的成员函数nativeLoad在C++层对应的函数为Dalvik_java_lang_Runtime_nativeLoad，这个函数定义在文件dalvik/vm/native/java_lang_Runtime.c中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_java_lang_Runtime_nativeLoad</span><span class="params">(<span class="keyword">const</span> u4* args,  </span><br><span class="line">    JValue* pResult)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    StringObject* fileNameObj = (StringObject*) args[<span class="number">0</span>]; <span class="comment">//so库名</span></span><br><span class="line">    Object* classLoader = (Object*) args[<span class="number">1</span>];  <span class="comment">//类加载器</span></span><br><span class="line">    <span class="keyword">char</span>* fileName = <span class="literal">NULL</span>;  </span><br><span class="line">    StringObject* result = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">char</span>* reason = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">bool</span> success;  </span><br><span class="line">  </span><br><span class="line">    assert(fileNameObj != <span class="literal">NULL</span>); </span><br><span class="line">    <span class="comment">//将 fileNameObj 转化为C++层字符串</span></span><br><span class="line">    fileName = dvmCreateCstrFromString(fileNameObj);  </span><br><span class="line">    <span class="comment">//调用dvmLoadNativeCode方法</span></span><br><span class="line">    success = dvmLoadNativeCode(fileName, classLoader, &amp;reason);  </span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* msg = (reason != <span class="literal">NULL</span>) ? reason : <span class="string">"unknown failure"</span>;  </span><br><span class="line">        result = dvmCreateStringFromCstr(msg);  </span><br><span class="line">        dvmReleaseTrackedAlloc((Object*) result, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(reason);  </span><br><span class="line">    <span class="built_in">free</span>(fileName);  </span><br><span class="line">    RETURN_PTR(result);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 参数args[0]保存的是一个Java层的String对象，这个String对象描述的就是要加载的so文件，函数Dalvik_java_lang_Runtime_nativeLoad首先是调用函数dvmCreateCstrFromString来将它转换成一个C++层的字符串fileName，然后再调用函数dvmLoadNativeCode来执行加载so文件的操作。</p>
<p>&#160; &#160; &#160; &#160;接下来，我们就继续分析函数dvmLoadNativeCode的实现，这个函数定义在文件dalvik/vm/Native.c中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmLoadNativeCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathName, Object* classLoader,  </span><br><span class="line">        <span class="keyword">char</span>** detail)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    SharedLib* pEntry;  </span><br><span class="line">    <span class="keyword">void</span>* handle;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    pEntry = findSharedLibEntry(pathName);  </span><br><span class="line">    <span class="keyword">if</span> (pEntry != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;classLoader != classLoader) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!checkOnLoadResult(pEntry))  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    handle = dlopen(pathName, RTLD_LAZY);  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* create a new entry */</span>  </span><br><span class="line">    SharedLib* pNewEntry;  </span><br><span class="line">    pNewEntry = (SharedLib*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(SharedLib));  </span><br><span class="line">    pNewEntry-&gt;pathName = strdup(pathName);  </span><br><span class="line">    pNewEntry-&gt;handle = handle;  </span><br><span class="line">    pNewEntry-&gt;classLoader = classLoader;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* try to add it to the list */</span>  </span><br><span class="line">    SharedLib* pActualEntry = addSharedLibEntry(pNewEntry);  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (pNewEntry != pActualEntry) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        freeSharedLibEntry(pNewEntry);  </span><br><span class="line">        <span class="keyword">return</span> checkOnLoadResult(pActualEntry);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">void</span>* vonLoad;  </span><br><span class="line">        <span class="keyword">int</span> version;  </span><br><span class="line">  </span><br><span class="line">        vonLoad = dlsym(handle, <span class="string">"JNI_OnLoad"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (vonLoad == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            LOGD(<span class="string">"No JNI_OnLoad found in %s %p, skipping init\n"</span>,  </span><br><span class="line">                pathName, classLoader);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            OnLoadFunc func = vonLoad;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            version = (*func)(gDvm.vmList, <span class="literal">NULL</span>);  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (version != JNI_VERSION_1_2 &amp;&amp; version != JNI_VERSION_1_4 &amp;&amp;  </span><br><span class="line">                version != JNI_VERSION_1_6)  </span><br><span class="line">            &#123;  </span><br><span class="line">                .......  </span><br><span class="line">                result = <span class="literal">false</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                LOGV(<span class="string">"+++ finished JNI_OnLoad %s\n"</span>, pathName);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (result)  </span><br><span class="line">            pNewEntry-&gt;onLoadResult = kOnLoadOkay;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            pNewEntry-&gt;onLoadResult = kOnLoadFailed;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数dvmLoadNativeCode首先是检查参数pathName所指定的so文件是否已经加载过了，这是通过调用函数findSharedLibEntry来实现的。如果已经加载过，那么就可以获得一个SharedLib对象pEntry。这个SharedLib对象pEntry描述了有关参数pathName所指定的so文件的加载信息，例如，上次用来加载它的类加载器和上次的加载结果。如果上次用来加载它的类加载器不等于当前所使用的类加载器，或者上次没有加载成功，那么函数dvmLoadNativeCode就回直接返回false给调用者，表示不能在当前进程中加载参数pathName所描述的so文件。</p>
<blockquote>
<p>这里有一个检测异常的代码，而这个错误，是我们在使用插件开发加载so的时候可能会遇到的错误，比如现在我们使用DexClassLoader类去加载插件，但是因为我们为了插件能够实时更新，所以每次都会赋值新的DexClassLoader对象，但是第一次加载so文件到内存中了，这时候退出程序，但是没有真正意义上的退出，只是关闭了Activity了，这时候再次启动又会赋值新的加载器对象，那么原先so已经加载到内存中了，但是这时候是新的类加载器那么就报错了，解决办法其实很简单，主要有两种方式：<br>第一种方式：在退出程序的时候采用真正意义上的退出，比如调用System.exit(0)方法，这时候进程被杀了，加载到内存的so也就被释放了，那么下次赋值新的类加载就在此加载so到内存了，<br>第二种方式：就是全局定义一个static类型的类加载DexClassLoader也是可以的，因为static类型是保存在当前进程中，如果进程没有被杀就一直存在这个对象，下次进入程序的时候判断当前类加载器是否为null，如果不为null就不要赋值了，但是这个方法有一个弊端就是类加载器没有从新赋值，如果插件这时候更新了，但是还是使用之前的加载器，那么新插件将不会进行加载。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;我们假设参数pathName所指定的so文件还没有被加载过，这时候函数dvmLoadNativeCode就会先调用dlopen来在当前进程中加载它，并且将获得的句柄保存在变量handle中，接着再创建一个SharedLib对象pNewEntry来描述它的加载信息。这个SharedLib对象pNewEntry还会通过函数addSharedLibEntry被缓存起来，以便可以知道当前进程都加载了哪些so文件。</p>
<p>&#160; &#160; &#160; &#160; 注意，在调用函数addSharedLibEntry来缓存新创建的SharedLib对象pNewEntry的时候，如果得到的返回值pActualEntry指向的不是SharedLib对象pNewEntry，那么就表示另外一个线程也正在加载参数pathName所指定的so文件，并且比当前线程提前加载完成。在这种情况下，函数addSharedLibEntry就什么也不用做而直接返回了。否则的话，函数addSharedLibEntry就要继续负责调用前面所加载的so文件中的一个指定的函数来注册它里面的JNI方法。</p>
<p>&#160; &#160; &#160; &#160; 这个指定的函数的名称为“JNI_OnLoad”，也就是说，每一个用来实现JNI方法的so文件都应该定义有一个名称为“JNI_OnLoad”的函数，并且这个函数的原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 函数dvmLoadNativeCode通过调用函数dlsym就可以获得在前面加载的so中名称为“JNI_OnLoad”的函数的地址，最终保存在函数指针func中。有了这个函数指针之后，我们就可以直接调用它来执行注册JNI方法的操作了。注意，在调用该JNI_OnLoad函数时，第一个要传递进行的参数是一个JavaVM对象，这个JavaVM对象描述的是在当前进程中运行的Dalvik虚拟机，第二个要传递的参数可以设置为NULL，这是保留给以后使用的。</p>
<p>&#160; &#160; &#160; &#160;到这里我们就总结一下Android中加载so的流程：</p>
<ul>
<li>调用System.loadLibrary和System.load方法进行加载so文件</li>
<li>通过Runtime.java类的nativeLoad方法进行最终调用，这里需要通过类加载器获取到nativeLib路径</li>
<li>到底层之后，就开始使用dlopen方法加载so文件，然后使用dlsym方法调用JNI_OnLoad方法，最终开始了so的执行</li>
</ul>
<h3 id="释放SO库文件"><a href="#释放SO库文件" class="headerlink" title="释放SO库文件"></a>释放SO库文件</h3><p>&#160; &#160; &#160; &#160;我们在使用System.loadLibrary加载so的时候，传递的是so文件的libxxx.so中的xxx部分，那么系统是如何找到这个so文件然后进行加载的呢？这个就要先从apk文件安装时机说起。</p>
<p> &#160; &#160; &#160; &#160;Android系统在启动的过程中，会启动一个应用程序管理服务PackageManagerService，这个服务负责扫描系统中特定的目录，找到里面的应用程序文件，即以Apk为后缀的文件，然后对这些文件进解析，得到应用程序的相关信息，完成应用程序的安装过程。<br>&#160; &#160; &#160; &#160;应用程序管理服务PackageManagerService安装应用程序的过程，其实就是解析析应用程序配置文件AndroidManifest.xml的过程，并从里面得到得到应用程序的相关信息，例如得到应用程序的组件Activity、Service、Broadcast Receiver和Content Provider等信息，有了这些信息后，通过ActivityManagerService这个服务，我们就可以在系统中正常地使用这些应用程序了。</p>
<p> &#160; &#160; &#160; &#160;下面我们一步一步分析：<br>  &#160; &#160; &#160; &#160;我们知道Android系统系统启动时会启动Zygote进程，Zygote进程又会启动SystemServer组件，启动的时候就会调用它的main函数，然后会初始化一系列服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PackageManagerService mPackageManagerService;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	startBootstrapServices();</span><br><span class="line">	......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">	&#125;	</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;中间会启动PackageManagerService，这个函数定义在frameworks/base/services/java/com/android/server/PackageManagerService.java文件中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerService</span> <span class="keyword">extends</span> <span class="title">IPackageManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span><br><span class="line">            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">                factoryTest, onlyCore);</span><br><span class="line">        ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数创建了一个PackageManagerService服务实例，然后把这个服务添加到ServiceManager中去， 在创建这个PackageManagerService服务实例时，会在PackageManagerService类的构造函数中开始执行安装应用程序的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span><br><span class="line">           <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">scanPackageLI(scanFile, reparseFlags, scanFlags, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;PackageManagerService的构造方法中就完成了对apk文件的解包，还有对xm文件的解析等等，感兴趣的可以自己分析。这里我们限于篇幅，就只分析so文件的解包过程。<br>&#160; &#160; &#160; &#160;这里会调用scanPackageLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span><br><span class="line">        <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......    </span><br><span class="line"> <span class="comment">// Note that we invoke the following method only if we are about to unpack an application</span></span><br><span class="line"> PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags</span><br><span class="line">            | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br><span class="line">            </span><br><span class="line">    ......                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span><br><span class="line">        <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......    </span><br><span class="line"> <span class="keyword">final</span> PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags,</span><br><span class="line">                currentTime, user);</span><br><span class="line">                </span><br><span class="line">    ......                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过一系列重载方法调用，最终会调用scanPackageDirtyLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageDirtyLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span><br><span class="line">         <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//初始化so库放置的目录，并赋值给pkg</span></span><br><span class="line">setNativeLibraryPaths(pkg);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isAsec = isForwardLocked(pkg) || isExternal(pkg);</span><br><span class="line">         <span class="comment">//nativeLibraryRootStr 指定为/data/app-lib/xxx(包名)</span></span><br><span class="line">         <span class="keyword">final</span> String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;</span><br><span class="line">         <span class="comment">//false</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;</span><br><span class="line"></span><br><span class="line">         NativeLibraryHelper.Handle handle = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//标记打开apk</span></span><br><span class="line">             handle = NativeLibraryHelper.Handle.create(scanFile);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">final</span> File nativeLibraryRoot = <span class="keyword">new</span> File(nativeLibraryRootStr);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Null out the abis so that they can be recalculated.</span></span><br><span class="line">             pkg.applicationInfo.primaryCpuAbi = <span class="keyword">null</span>;</span><br><span class="line">             pkg.applicationInfo.secondaryCpuAbi = <span class="keyword">null</span>;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">                 String[] abiList = (cpuAbiOverride != <span class="keyword">null</span>) ?</span><br><span class="line">                         <span class="keyword">new</span> String[] &#123; cpuAbiOverride &#125; : Build.SUPPORTED_ABIS;</span><br><span class="line"></span><br><span class="line">	    ......</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> copyRet;</span><br><span class="line">                 <span class="keyword">if</span> (isAsec) &#123;</span><br><span class="line">                     copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//解压对应ABI的so文件到指定目录</span></span><br><span class="line">                     copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,</span><br><span class="line">                             nativeLibraryRoot, abiList, useIsaSpecificSubdirs);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">         ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scanPackageDirtyLI首先调用setNativeLibraryPaths方法，这个方法主要是指定一下so库释放路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNativeLibraryPaths</span><span class="params">(PackageParser.Package pkg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ApplicationInfo info = pkg.applicationInfo;</span><br><span class="line">       <span class="keyword">final</span> String codePath = pkg.codePath;</span><br><span class="line">       <span class="keyword">final</span> File codeFile = <span class="keyword">new</span> File(codePath);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> bundledApp = isSystemApp(info) &amp;&amp; !isUpdatedSystemApp(info);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> asecApp = isForwardLocked(info) || isExternal(info);</span><br><span class="line"></span><br><span class="line">       info.nativeLibraryRootDir = <span class="keyword">null</span>;</span><br><span class="line">       info.nativeLibraryRootRequiresIsa = <span class="keyword">false</span>;</span><br><span class="line">       info.nativeLibraryDir = <span class="keyword">null</span>;</span><br><span class="line">       info.secondaryNativeLibraryDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isApkFile(codeFile)) &#123;</span><br><span class="line">           <span class="comment">// Monolithic install</span></span><br><span class="line">           <span class="keyword">if</span> (bundledApp) &#123;</span><br><span class="line">		......</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (asecApp) &#123;</span><br><span class="line">		......</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> String apkName = deriveCodePathName(codePath);</span><br><span class="line">               <span class="comment">//mAppLib32InstallDir为/data/app-lib/</span></span><br><span class="line">               info.nativeLibraryRootDir = <span class="keyword">new</span> File(mAppLib32InstallDir, apkName)</span><br><span class="line">                       .getAbsolutePath();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           info.nativeLibraryRootRequiresIsa = <span class="keyword">false</span>;</span><br><span class="line">           info.nativeLibraryDir = info.nativeLibraryRootDir;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ......</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后调用NativeLibraryHelper.Handle.create(scanFile)标记打开apk文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		......</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] apkHandles;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> multiArch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(File packageFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> PackageLite lite = PackageParser.parsePackageLite(packageFile, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> create(lite);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to parse package: "</span> + packageFile, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> create(pkg.getAllCodePaths(),</span><br><span class="line">                    (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_MULTIARCH) != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(PackageLite lite)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> create(lite.getAllCodePaths(), lite.multiArch);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//最后调用到这里</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(List&lt;String&gt; codePaths, <span class="keyword">boolean</span> multiArch)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = codePaths.size();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span>[] apkHandles = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> String path = codePaths.get(i);</span><br><span class="line">                <span class="comment">//调用这个native方法，打开apk，并将JNI层返回的句柄保留到java层</span></span><br><span class="line">                apkHandles[i] = nativeOpenApk(path);</span><br><span class="line">                </span><br><span class="line">				......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Handle(apkHandles, multiArch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Handle(<span class="keyword">long</span>[] apkHandles, <span class="keyword">boolean</span> multiArch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.apkHandles = apkHandles;</span><br><span class="line">            <span class="keyword">this</span>.multiArch = multiArch;</span><br><span class="line">            mGuard.open(<span class="string">"close"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//NativeLibraryHelper的nativeOpenApk方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeOpenApk</span><span class="params">(String path)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过一系列重载方法调用，最后会调用NativeLibraryHelper的nativeOpenApk方法，打开apk，并将JNI层返回的句柄保留到java层。这个方法的实现位于frameworks/base/core/jni/com_android_internal_content_NativeLibraryHelper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_openApk</span><span class="params">(JNIEnv *env, jclass, jstring apkPath)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">filePath</span><span class="params">(env, apkPath)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ZipFileRO* zipFile = ZipFileRO::open(filePath.c_str());</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(zipFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码调用了ZipFileRO的open方法，并返回一个ZipFileRO类型的指针，然后强转为java层的long型对象返回给java层。open方法实现位于frameworks/base/libs/androidfw/ZipFileRO.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Open the specified file read-only.  We memory-map the entire thing and</span><br><span class="line"> * close the file before returning.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/* static */</span> ZipFileRO* ZipFileRO::open(<span class="keyword">const</span> <span class="keyword">char</span>* zipFileName)</span><br><span class="line">&#123;</span><br><span class="line">    ZipArchiveHandle handle;</span><br><span class="line">    <span class="comment">//调用ZipArchive库打开zip文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> error = OpenArchive(zipFileName, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error opening archive %s: %s"</span>, zipFileName, ErrorCodeString(error));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZipFileRO(handle, strdup(zipFileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这些就是JNI层打开apk文件的操作了。我么继续回到scanPackageDirtyLI方法中，接着调用NativeLibraryHelper.copyNativeBinariesForSupportedAbi方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copyNativeBinariesForSupportedAbi</span><span class="params">(Handle handle, File libraryRoot,</span><br><span class="line">         String[] abiList, <span class="keyword">boolean</span> useIsaSubdir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//如果目录不存或者是个文件，就重新创建目录    </span></span><br><span class="line">     createNativeLibrarySubdir(libraryRoot);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span><br><span class="line">      * If this is an internal application or our nativeLibraryPath points to</span><br><span class="line">      * the app-lib directory, unpack the libraries if necessary.</span><br><span class="line">      */</span></span><br><span class="line">      <span class="comment">//查找对应的ABI类型</span></span><br><span class="line">     <span class="keyword">int</span> abi = findSupportedAbi(handle, abiList);</span><br><span class="line">     <span class="keyword">if</span> (abi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/*</span><br><span class="line">          * If we have a matching instruction set, construct a subdir under the native</span><br><span class="line">          * library root that corresponds to this instruction set.</span><br><span class="line">          */</span></span><br><span class="line">         <span class="comment">//获取so释放之后的目录</span></span><br><span class="line">         <span class="keyword">final</span> String instructionSet = VMRuntime.getInstructionSet(abiList[abi]);</span><br><span class="line">         <span class="keyword">final</span> File subDir;</span><br><span class="line">         <span class="keyword">if</span> (useIsaSubdir) &#123;</span><br><span class="line">             <span class="keyword">final</span> File isaSubdir = <span class="keyword">new</span> File(libraryRoot, instructionSet);</span><br><span class="line">             createNativeLibrarySubdir(isaSubdir);</span><br><span class="line">             subDir = isaSubdir;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             subDir = libraryRoot;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//拷贝so</span></span><br><span class="line">         <span class="keyword">int</span> copyRet = copyNativeBinaries(handle, subDir, abiList[abi]);</span><br><span class="line">         <span class="keyword">if</span> (copyRet != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">             <span class="keyword">return</span> copyRet;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> abi;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们挑一些重要的分析一下。这里先获取abiList的值，这个通过Build.SUPPORTED_ABIS来获取到的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SUPPORTED_ABIS = getStringList(<span class="string">"ro.product.cpu.abilist"</span>, <span class="string">","</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最终是通过获取系统属性ro.product.cpu.abilist的值来得到的，我们可以使用getprop命令来查看这个属性值，或者直接cat一下/system/build.prop文件:<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/adb.png" alt="查看ABI"><br>&#160; &#160; &#160; &#160;这里获取到的值是x86。然后去分析findSupportedAbi方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSupportedAbi</span><span class="params">(Handle handle, String[] supportedAbis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> finalRes = NO_NATIVE_LIBRARIES;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> apkHandle : handle.apkHandles) &#123;</span><br><span class="line">        <span class="comment">//这里调用了native方法</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> res = nativeFindSupportedAbi(apkHandle, supportedAbis);</span><br><span class="line">           <span class="keyword">if</span> (res == NO_NATIVE_LIBRARIES) &#123;</span><br><span class="line">               <span class="comment">// No native code, keep looking through all APKs.</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == INSTALL_FAILED_NO_MATCHING_ABIS) &#123;</span><br><span class="line">               <span class="comment">// Found some native code, but no ABI match; update our final</span></span><br><span class="line">               <span class="comment">// result if we haven't found other valid code.</span></span><br><span class="line">               <span class="keyword">if</span> (finalRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   finalRes = INSTALL_FAILED_NO_MATCHING_ABIS;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Found valid native code, track the best ABI match</span></span><br><span class="line">               <span class="keyword">if</span> (finalRes &lt; <span class="number">0</span> || res &lt; finalRes) &#123;</span><br><span class="line">                   finalRes = res;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Unexpected error; bail</span></span><br><span class="line">               <span class="keyword">return</span> res;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> finalRes;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeFindSupportedAbi</span><span class="params">(<span class="keyword">long</span> handle, String[] supportedAbis)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;NativeLibraryHelper类的findSupportedAbi方法，其实这个方法就是查找系统当前支持的架构型号索引值。调用的本地方法实现为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_findSupportedAbi</span><span class="params">(JNIEnv *env, jclass clazz,</span><br><span class="line">        jlong apkHandle, jobjectArray javaCpuAbisToSearch)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (jint) findSupportedAbi(env, apkHandle, javaCpuAbisToSearch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSupportedAbi</span><span class="params">(JNIEnv *env, jlong apkHandle, jobjectArray supportedAbisArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> numAbis = env-&gt;GetArrayLength(supportedAbisArray);</span><br><span class="line">    Vector&lt;ScopedUtfChars*&gt; supportedAbis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; ++i) &#123;</span><br><span class="line">        supportedAbis.add(<span class="keyword">new</span> ScopedUtfChars(env,</span><br><span class="line">            (jstring) env-&gt;GetObjectArrayElement(supportedAbisArray, i)));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//读取apk文件</span></span><br><span class="line">    ZipFileRO* zipFile = <span class="keyword">reinterpret_cast</span>&lt;ZipFileRO*&gt;(apkHandle);</span><br><span class="line">    <span class="keyword">if</span> (zipFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;NativeLibrariesIterator&gt; it(NativeLibrariesIterator::create(zipFile));</span><br><span class="line">    <span class="keyword">if</span> (it.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipEntryRO entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> fileName[PATH_MAX];</span><br><span class="line">    <span class="keyword">int</span> status = NO_NATIVE_LIBRARIES;</span><br><span class="line">    <span class="comment">//这里开始遍历apk中每一个文件</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = it-&gt;next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We're currently in the lib/ directory of the APK, so it does have some native</span></span><br><span class="line">        <span class="comment">// code. We should return INSTALL_FAILED_NO_MATCHING_ABIS if none of the</span></span><br><span class="line">        <span class="comment">// libraries match.</span></span><br><span class="line">        <span class="keyword">if</span> (status == NO_NATIVE_LIBRARIES) &#123;</span><br><span class="line">            status = INSTALL_FAILED_NO_MATCHING_ABIS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* fileName = it-&gt;currentEntry();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* lastSlash = it-&gt;lastSlash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if this CPU ABI matches what we are looking for.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* abiOffset = fileName + APK_LIB_LEN;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> abiSize = lastSlash - abiOffset;</span><br><span class="line">        <span class="comment">//遍历apk中的子文件，获取so文件的全路径，如果这个路径包含了cpu架构值，就记录返回索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> ScopedUtfChars* abi = supportedAbis[i];</span><br><span class="line">            <span class="keyword">if</span> (abi-&gt;size() == abiSize &amp;&amp; !<span class="built_in">strncmp</span>(abiOffset, abi-&gt;c_str(), abiSize)) &#123;</span><br><span class="line">                <span class="comment">// The entry that comes in first (i.e. with a lower index) has the higher priority.</span></span><br><span class="line">                <span class="keyword">if</span> (((i &lt; status) &amp;&amp; (status &gt;= <span class="number">0</span>)) || (status &lt; <span class="number">0</span>) ) &#123;</span><br><span class="line">                    status = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> supportedAbis[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里看到了，会先读取apk文件，然后遍历apk文件中的so文件，得到全路径然后在和传递进来的abiList进行比较，得到合适的索引值。我们刚才拿到的abiList为：x86，然后就开始比较apk中有没有这些架构平台的so文件，如果有，就直接返回abiList中的索引值即可。比如apk中libs结构如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/apk.png" alt="apk的libs结构"></p>
<p>&#160; &#160; &#160; &#160;那么这个时候就只有这么一种架构，libs文件下也有相关的ABI类型，就只能返回0了；</p>
<p>&#160; &#160; &#160; &#160;假设我们的abiList为：arm64-v8a,armeabi-v7a,armeabi。那么这时候返回来的索引值就是0，代表的是arm64-v8a架构的。如果apk文件中没有arm64-v8a目录的话，那么就返回1，代表的是armeabi-v7a架构的。依次类推。得到应用支持的架构索引之后就可以获取so释放到设备中的目录了。</p>
<p>&#160; &#160; &#160; &#160;下一步就是获取so释放之后的目录，调用VMRuntime.java中的getInstructionSet方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstructionSet</span><span class="params">(String abi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String instructionSet = ABI_TO_INSTRUCTION_SET_MAP.get(abi);</span><br><span class="line">    <span class="keyword">if</span> (instructionSet == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported ABI: "</span> + abi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instructionSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; ABI_TO_INSTRUCTION_SET_MAP</span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"armeabi"</span>, <span class="string">"arm"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"armeabi-v7a"</span>, <span class="string">"arm"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"mips"</span>, <span class="string">"mips"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"mips64"</span>, <span class="string">"mips64"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"x86"</span>, <span class="string">"x86"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"x86_64"</span>, <span class="string">"x86_64"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"arm64-v8a"</span>, <span class="string">"arm64"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步主要是对获得的ABI架构字符串做了一下转换，比如从x86—&gt;x86，armeabi—&gt;arm等等。</p>
<p>&#160; &#160; &#160; &#160;最后就是释放so了，调用copyNativeBinaries方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copyNativeBinaries</span><span class="params">(Handle handle, File sharedLibraryDir, String abi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> apkHandle : handle.apkHandles) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = nativeCopyNativeBinaries(apkHandle, sharedLibraryDir.getPath(), abi);</span><br><span class="line">        <span class="keyword">if</span> (res != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeCopyNativeBinaries</span><span class="params">(<span class="keyword">long</span> handle,</span><br><span class="line">        String sharedLibraryPath, String abiToCopy)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;JNI层实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_copyNativeBinaries</span><span class="params">(JNIEnv *env, jclass clazz,</span><br><span class="line">        jlong apkHandle, jstring javaNativeLibPath, jstring javaCpuAbi)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//调用iterateOverNativeFiles方法，copyFileIfChanged是个函数指针，完成释放</span></span><br><span class="line">    <span class="keyword">return</span> (jint) iterateOverNativeFiles(env, apkHandle, javaCpuAbi,</span><br><span class="line">            copyFileIfChanged, &amp;javaNativeLibPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> install_status_t</span><br><span class="line"><span class="title">iterateOverNativeFiles</span><span class="params">(JNIEnv *env, jlong apkHandle, jstring javaCpuAbi,</span><br><span class="line">                       iterFunc callFunc, <span class="keyword">void</span>* callArg)</span> </span>&#123;</span><br><span class="line">    ZipFileRO* zipFile = <span class="keyword">reinterpret_cast</span>&lt;ZipFileRO*&gt;(apkHandle);</span><br><span class="line">    <span class="keyword">if</span> (zipFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;NativeLibrariesIterator&gt; it(NativeLibrariesIterator::create(zipFile));</span><br><span class="line">    <span class="keyword">if</span> (it.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> ScopedUtfChars <span class="title">cpuAbi</span><span class="params">(env, javaCpuAbi)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cpuAbi.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// This would've thrown, so this return code isn't observable by</span></span><br><span class="line">        <span class="comment">// Java.</span></span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line">    ZipEntryRO entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = it-&gt;next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* fileName = it-&gt;currentEntry();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* lastSlash = it-&gt;lastSlash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure the CPU ABI of this file is one we support.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cpuAbiOffset = fileName + APK_LIB_LEN;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cpuAbiRegionSize = lastSlash - cpuAbiOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpuAbi.size() == cpuAbiRegionSize &amp;&amp; !<span class="built_in">strncmp</span>(cpuAbiOffset, cpuAbi.c_str(), cpuAbiRegionSize)) &#123;</span><br><span class="line">	        <span class="comment">//释放so，这一句才是关键，copyFileIfChanged完成释放</span></span><br><span class="line">            <span class="keyword">install_status_t</span> ret = callFunc(env, callArg, zipFile, entry, lastSlash + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                ALOGV(<span class="string">"Failure for entry %s"</span>, lastSlash + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后的释放工作都交给了copyFileIfChanged函数，我们看看这个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Copy the native library if needed.</span><br><span class="line"> *</span><br><span class="line"> * This function assumes the library and path names passed in are considered safe.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> install_status_t</span><br><span class="line"><span class="title">copyFileIfChanged</span><span class="params">(JNIEnv *env, <span class="keyword">void</span>* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, <span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jstring* javaNativeLibPath = (jstring*) arg;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">nativeLibPath</span><span class="params">(env, *javaNativeLibPath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> uncompLen;</span><br><span class="line">    <span class="keyword">long</span> when;</span><br><span class="line">    <span class="keyword">long</span> crc;</span><br><span class="line">    <span class="keyword">time_t</span> modTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zipFile-&gt;getEntryInfo(zipEntry, <span class="literal">NULL</span>, &amp;uncompLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;when, &amp;crc)) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't read zip entry info\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> tm t;</span><br><span class="line">        ZipUtils::zipTimeToTimespec(when, &amp;t);</span><br><span class="line">        modTime = mktime(&amp;t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build local file path</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fileNameLen = <span class="built_in">strlen</span>(fileName);</span><br><span class="line">    <span class="keyword">char</span> localFileName[nativeLibPath.size() + fileNameLen + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localFileName, nativeLibPath.c_str(), <span class="keyword">sizeof</span>(localFileName)) != nativeLibPath.size()) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(localFileName + nativeLibPath.size()) = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localFileName + nativeLibPath.size() + <span class="number">1</span>, fileName, <span class="keyword">sizeof</span>(localFileName)</span><br><span class="line">                    - nativeLibPath.size() - <span class="number">1</span>) != fileNameLen) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only copy out the native file if it's different.</span></span><br><span class="line">    <span class="comment">//只有so本地文件改变了才拷贝</span></span><br><span class="line">    <span class="keyword">struct</span> stat64 st;</span><br><span class="line">    <span class="keyword">if</span> (!isFileDifferent(localFileName, uncompLen, modTime, crc, &amp;st)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> localTmpFileName[nativeLibPath.size() + TMP_FILE_PATTERN_LEN + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localTmpFileName, nativeLibPath.c_str(), <span class="keyword">sizeof</span>(localTmpFileName))</span><br><span class="line">            != nativeLibPath.size()) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(localFileName + nativeLibPath.size()) = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localTmpFileName + nativeLibPath.size(), TMP_FILE_PATTERN,</span><br><span class="line">                    TMP_FILE_PATTERN_LEN - nativeLibPath.size()) != TMP_FILE_PATTERN_LEN) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't allocate temporary file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//生成一个临时文件，用于拷贝</span></span><br><span class="line">    <span class="keyword">int</span> fd = mkstemp(localTmpFileName);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't open temporary file name: %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解压so文件</span></span><br><span class="line">    <span class="keyword">if</span> (!zipFile-&gt;uncompressEntry(zipEntry, fd)) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Failed uncompressing %s to %s\n"</span>, fileName, localTmpFileName);</span><br><span class="line">        close(fd);</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the modification time for this file to the ZIP's mod time.</span></span><br><span class="line">    <span class="keyword">struct</span> timeval times[<span class="number">2</span>];</span><br><span class="line">    times[<span class="number">0</span>].tv_sec = st.st_atime;</span><br><span class="line">    times[<span class="number">1</span>].tv_sec = modTime;</span><br><span class="line">    times[<span class="number">0</span>].tv_usec = times[<span class="number">1</span>].tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (utimes(localTmpFileName, times) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't change modification time on %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the mode to 755</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">mode_t</span> mode = S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP |  S_IXGRP | S_IROTH | S_IXOTH;</span><br><span class="line">    <span class="keyword">if</span> (chmod(localTmpFileName, mode) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't change permissions on %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, rename it to the final name.</span></span><br><span class="line">    <span class="keyword">if</span> (rename(localTmpFileName, localFileName) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't rename %s to %s: %s\n"</span>, localTmpFileName, localFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Successfully moved %s to %s\n"</span>, localTmpFileName, localFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是解压so文件的实现。先判断so名字合不合法，然后判断是不是文件改变了，再者创建一个临时文件，最后解压，用临时文件拷贝so到指定目录，结尾处关闭一些链接。</p>
<p>&#160; &#160; &#160; &#160;小结一下上述SO释放流程：</p>
<ul>
<li>通过遍历apk文件中的so文件的全路径，然后和系统的abiList中的类型值进行比较，如果匹配到了就返回arch类型的索引值</li>
<li>得到了应用所支持的arch类型之后，就开始获取创建本地释放so的目录</li>
<li>然后开始释放so文件</li>
</ul>
<h1 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h1><p>&#160; &#160; &#160; &#160;上面我们分析了插件apk中加载so库，必须指定DexClassLoader中第三个参数，这就要我们解压apk中的so了。所以我试着调用系统的NativeLibraryHelper相关方法，做了如下实验：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(<span class="string">"NewApi"</span>)</span><br><span class="line">@<span class="function">Override</span><br><span class="line"><span class="keyword">public</span> boolean <span class="title">loadSO</span><span class="params">(File apkFile, File nativeLibraryRoot)</span> </span>&#123;</span><br><span class="line">	NativeLibraryHelper.Handle handle = null;</span><br><span class="line"> 	<span class="keyword">try</span> &#123;</span><br><span class="line">		handle = NativeLibraryHelper.Handle.create(apkFile);</span><br><span class="line"> 		<span class="comment">//private static Handle create(List&lt;String&gt; codePaths, boolean multiArch) throws IOException</span></span><br><span class="line"> 		<span class="comment">/*Method create2 = NativeLibraryHelper.Handle.class.getDeclaredMethod("create", List.class, boolean.class);</span><br><span class="line"> 		create2.setAccessible(true);</span><br><span class="line"> 		List&lt;String&gt; apkList = new ArrayList&lt;String&gt;();</span><br><span class="line"> 		apkList.add(apkFile.getAbsolutePath());</span><br><span class="line"> 		handle = (Handle) create2.invoke(null, apkList, false);*/</span></span><br><span class="line"> 		<span class="comment">/*Method nativeOpenApk = NativeLibraryHelper.class.getDeclaredMethod("nativeOpenApk", String.class);</span><br><span class="line"> 		nativeOpenApk.setAccessible(true);</span><br><span class="line"> 		long apkHandle = (long) nativeOpenApk.invoke(null, apkFile.getAbsolutePath());</span><br><span class="line"> 		</span><br><span class="line"> 		Method nativeClose = NativeLibraryHelper.class.getDeclaredMethod("nativeClose", long.class);</span><br><span class="line"> 		nativeOpenApk.setAccessible(true);</span><br><span class="line"> 		nativeClose.invoke(null, apkHandle);</span><br><span class="line"> 		</span><br><span class="line"> 		Constructor&lt;Handle&gt; constructMethod = NativeLibraryHelper.Handle.class.getConstructor(long[].class, boolean.class);</span><br><span class="line"> 		constructMethod.setAccessible(true);</span><br><span class="line"> 		handle = constructMethod.newInstance(new long[]&#123;apkHandle&#125;, false);*/</span></span><br><span class="line"> 		</span><br><span class="line"> 		NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,</span><br><span class="line">                   nativeLibraryRoot, Build.SUPPORTED_ABIS, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		<span class="keyword">if</span> (handle != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	handle.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而并无卵用。。。。。。还有那些注释的尝试，也毫无作用= 。 =<br>&#160; &#160; &#160; &#160;如果大家知道原因的话，或者对这一块儿还有更好的实现方案，麻烦多多指教，在此提前献上妹子图。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/meizi.jpg" alt="妹子图"></p>
<h1 id="剩下的坑"><a href="#剩下的坑" class="headerlink" title="剩下的坑"></a>剩下的坑</h1><p>&#160; &#160; &#160; &#160;关于四大组件生命周期的管理也是一个难点，这里限于篇幅只能止步于此。如果以后有时间的话，我会努力补上。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/09/05/插件开发中的资源问题分析及填坑处理/">插件开发中的资源问题分析及填坑处理</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">windrunnerlihuan</a></p>
        <p><span>发布时间:</span>2016-09-05, 18:44:12</p>
        <p><span>最后更新:</span>2016-09-06, 06:28:17</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/09/05/插件开发中的资源问题分析及填坑处理/" title="插件开发中的资源问题分析及填坑处理">http://windrunnerlihuan.com/2016/09/05/插件开发中的资源问题分析及填坑处理/</a>
            <span class="copy-path" data-clipboard-text="原文: http://windrunnerlihuan.com/2016/09/05/插件开发中的资源问题分析及填坑处理/　　作者: windrunnerlihuan" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/09/18/如何实现1080P延迟低于500ms的实时超清直播传输技术/">
                    如何实现1080P延迟低于500ms的实时超清直播传输技术
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/08/23/智能指针简单分析/">
                    智能指针简单分析
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#普通插件开发"><span class="toc-number">1.</span> <span class="toc-text">普通插件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#开发前提"><span class="toc-number">1.1.</span> <span class="toc-text">开发前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本流程"><span class="toc-number">1.2.</span> <span class="toc-text">基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载资源"><span class="toc-number">1.3.</span> <span class="toc-text">加载资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#普通资源"><span class="toc-number">1.3.1.</span> <span class="toc-text">普通资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout资源"><span class="toc-number">1.3.2.</span> <span class="toc-text">Layout资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#另外三种方式"><span class="toc-number">1.3.3.</span> <span class="toc-text">另外三种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载SO库流程分析和填坑"><span class="toc-number">1.4.</span> <span class="toc-text">加载SO库流程分析和填坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SO库加载过程"><span class="toc-number">1.4.1.</span> <span class="toc-text">SO库加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放SO库文件"><span class="toc-number">1.4.2.</span> <span class="toc-text">释放SO库文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#失败的尝试"><span class="toc-number">2.</span> <span class="toc-text">失败的尝试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#剩下的坑"><span class="toc-number">3.</span> <span class="toc-text">剩下的坑</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"插件开发中的资源问题分析及填坑处理　| April is your lie　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
      <div class="duoshuo" id="comments">
    <!-- ��˵���ۿ� start -->
    <div class="ds-thread" data-thread-key="2016/09/05/插件开发中的资源问题分析及填坑处理/" data-title="插件开发中的资源问题分析及填坑处理" data-url="http://windrunnerlihuan.com/2016/09/05/插件开发中的资源问题分析及填坑处理/"></div>
    <!-- ��˵���ۿ� end -->
    <!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"windrunnerlihuan"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://windrunnerlihuan.com/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- ��˵����JS���� end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/09/18/如何实现1080P延迟低于500ms的实时超清直播传输技术/" title="上一篇: 如何实现1080P延迟低于500ms的实时超清直播传输技术">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/08/23/智能指针简单分析/" title="下一篇: 智能指针简单分析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/">Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/Android多媒体开发-九-Video-Buffer传输与Audio-Playback流程/">Android多媒体开发(九)----Video Buffer传输与Audio Playback流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/06/Android多媒体开发-八-播放流程/">Android多媒体开发(八)----播放流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/29/Android多媒体开发-七-Android中OpenMax的实现/">Android多媒体开发(七)----Android中OpenMax的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/">Android多媒体开发(六)----Android中OpenMax的实现(preview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/Android多媒体开发-五-OpenMax简介/">Android多媒体开发(五)----OpenMax简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/Android多媒体开发-四-AwesomePlayer数据源处理/">Android多媒体开发(四)----AwesomePlayer数据源处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/Android多媒体开发-三-从StageFright到AwesomePlayer/">Android多媒体开发(三)----从StageFright到AwesomePlayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/30/Android多媒体开发-二-MediaPlayer的C-S架构以及C-层调用步骤/">Android多媒体开发(二)----MediaPlayer的C/S架构以及C++层调用步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/Android多媒体开发-一-MediaPlayer框架开始/">Android多媒体开发(一)----MediaPlayer框架开始</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/31/JAVA线程池简单分析/">JAVA线程池简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/Android壁纸开发流程分析/">Android壁纸开发流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/如何实现1080P延迟低于500ms的实时超清直播传输技术/">如何实现1080P延迟低于500ms的实时超清直播传输技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/插件开发中的资源问题分析及填坑处理/">插件开发中的资源问题分析及填坑处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/智能指针简单分析/">智能指针简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/31/Android消息机制零散分析/">Android消息处理零散分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/12/浅析Bitmap占据内存大小/">浅析Bitmap占据内存大小</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/DanmakuFlameMaster简单分析/">弹幕框架DanmakuFlameMaster简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/24/Android属性动画原理分析/">Android属性动画流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/Binder简要分析/">Android跨进程通信机制Binder简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/移动直播技术秒开优化经验/">移动直播技术秒开优化经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/博客搭建历程/">博客搭建历程————————Github和Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/新的开始/">新的开始</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 windrunnerlihuan
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.0">Yelee</a> by HuanLi & MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>